options {
  JDK_VERSION = "1.19";
  //FORCE_LA_CHECK=true;
  MULTI=true;
  STATIC=false;
  VISITOR=false;
  NODE_DEFAULT_VOID=false;
}
PARSER_BEGIN(JavaccParser)
/*
 * Project: script
 *
 * Copyright (c) 2023,  Prof. Dr. Nikolaus Wulff
 * University of Applied Sciences, Muenster, Germany
 * Lab for computer sciences (Lab4Inf).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package de.fh_muenster.blackboard.scripting;
import java.io.*;
import java.util.*;
import de.fh_muenster.blackboard.scripting.AST;
import de.fh_muenster.blackboard.scripting.Parser;
import static de.fh_muenster.blackboard.scripting.AST.*;
/**
 * Concrete JavaCC based part of the abstract Parser.
 * TODO: extend  the grammar 
 * @author nwulff
 * @since 03.07.2023
 *
 */
public class JavaccParser extends Parser {
    public final static String ENCODING = "utf-8";
  
    public JavaccParser() {
      this(new StringReader(""));
    }
	@Override
	public AST<?> parse(String stm) {
	    Objects.requireNonNull(stm,"parse String is null");
		ReInit(new StringReader(stm));
		AST<?> ret = null;
		try {
			ret = statement();
		} catch (ParseException e) {
			//e.printStackTrace();
			throw new IllegalArgumentException(stm);
		}
		return ret;
	}  
}

PARSER_END(JavaccParser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : /* LITERALS */
{  
  < INTEGER_LITERAL:  (
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
    )
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
}

TOKEN : /* FLOATING POINT */
{
  < FLOATING_LITERAL:  (<DIGIT>)* "." (<DIGIT >)* >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}

TOKEN : {  < ASSIGN: "=" > }  
TOKEN : {  < SEMI  : ";" > }  
TOKEN : {  < PLUS  : "+" > }  
TOKEN : {  < MINUS : "-" > }  
TOKEN : {  < TIMES : "*" > }  
TOKEN : {  < DIVIDE: "/" > }  
TOKEN : {  < POWER : "^" | "**" > }  
TOKEN : {  < LPARA : "(" > }  
TOKEN : {  < RPARA : ")" > }  


/** statement. */
protected AST<?> statement(): {
  AST<?> n=null;}
{
  (   // TODO functions are missing
      LOOKAHEAD(3) n = assignment()
    | LOOKAHEAD(2) n = expr()
  )
  {
    return n;
  }
}

/** assignment. */
protected AST<?> assignment(): {
  AST<?> n=null, m = null;  AST<String> id;}
{
  ( id = id() < ASSIGN > m = expr() {n = node(id,m);  return n; }) 
}


/** additive expression. */
protected AST<?> expr(): {
  AST<?> n=null, m = null;
  Token op=null;}
{  
  ( n = secondLevelExpr()
      (   (op=< PLUS > |op=< MINUS > ) m=secondLevelExpr()
          {
              n = node(n,op.image,m);
          }
      )* 
  ) 
   {
	return n;
   }
}

protected AST<?> secondLevelExpr(): {
  AST<?> n=null, m = null;
  Token op=null;}
{
  ( n = leaf()
      (   (op=< TIMES > |op=< DIVIDE >) m=leaf()
          {
              n = node(n,op.image,m);
          }
      )*
  )
   {
	return n;
   }
}

protected AST<?> leaf(): {
  AST<?> n=null, m = null;
  Token op=null;}
{
  ( n = id()
  | n = integer()
  | n = floating()
  ) 
   {
	return n;
   }
}

/** an identifier. */
protected AST<String> id(): {Token t;} {
  t=<IDENTIFIER>
  {
	return node(t.image);
  }
}

/** an integer number. */
protected AST<Long> integer()  : {
  Token t =null;} {
  t=<INTEGER_LITERAL>
  {
	return node(Long.valueOf(t.image));
  }
}

/** a floating point number. */
protected AST<Double> floating(): {
  Token t =null;} {
  t=<FLOATING_LITERAL>
  {
	return node(Double.valueOf(t.image));
  }
}
